<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>交互式折线图</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      padding: 20px;
    }
    .chart-container {
      width: 900px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      padding: 24px;
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .chart-title {
      font-size: 24px;
      font-weight: 600;
      color: #2c3e50;
    }
    .controls {
      display: flex;
      gap: 12px;
    }
    button {
      padding: 8px 16px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    button:hover {
      background: #2980b9;
      transform: translateY(-2px);
    }
    button.active {
      background: #16a085;
    }
    .canvas-container {
      position: relative;
      width: 100%;
      height: 400px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      overflow: hidden;
    }
    canvas {
      background: #f8fafc;
      width: 100%;
      height: 100%;
    }
    .slider-container {
      margin-top: 20px;
      padding: 0 10px;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      color: #546e7a;
      font-size: 14px;
    }
    .slider {
      width: 100%;
      height: 5px;
      -webkit-appearance: none;
      appearance: none;
      background: #ddd;
      border-radius: 5px;
      outline: none;
    }
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #3498db;
      cursor: pointer;
      transition: all 0.2s;
    }
    .slider::-webkit-slider-thumb:hover {
      background: #2980b9;
      transform: scale(1.2);
    }
    .chart-footer {
      display: flex;
      justify-content: space-between;
      margin-top: 16px;
      color: #546e7a;
      font-size: 14px;
    }
    .data-point-info {
      background: #f1f8e9;
      padding: 12px;
      border-radius: 6px;
      margin-top: 16px;
      display: none;
    }
    .data-point-info.visible {
      display: block;
    }
    .zoom-info {
      font-weight: 500;
      color: #3498db;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="chart-container">
      <div class="chart-header">
        <h2 class="chart-title">销售趋势分析</h2>
        <div class="controls">
          <button @click="zoomOut" :disabled="zoomLevel <= 1">缩小</button>
          <button @click="zoomIn" :disabled="zoomLevel >= 5">放大</button>
          <button @click="resetView">重置视图</button>
          <button 
            @click="toggleMarkerMode" 
            :class="{ active: markerMode }"
          >{{ markerMode ? '标记模式开启' : '标记模式关闭' }}</button>
        </div>
      </div>

      <div class="canvas-container">
        <canvas ref="canvas" @click="handleCanvasClick"></canvas>
      </div>

      <div class="slider-container">
        <div class="slider-label">
          <span>视图位置</span>
          <span class="zoom-info">缩放级别: {{ zoomLevel }}x</span>
        </div>
        <input 
          type="range" 
          min="0" 
          max="100" 
          v-model="sliderPosition" 
          class="slider"
          @input="updateViewPosition"
        >
      </div>

      <div class="chart-footer">
        <div>数据范围: {{ Math.round(visibleDataRange[0]) }} - {{ Math.round(visibleDataRange[1]) }}</div>
        <div>数据点总数: {{ data.length }}</div>
        <div>可见数据点: {{ Math.round(visibleDataPoints) }}</div>
      </div>

      <div class="data-point-info" :class="{ visible: selectedPoint }">
        <div v-if="selectedPoint">
          选中数据点: X = {{ selectedPoint.x }}, Y = {{ selectedPoint.y }}
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp, ref, onMounted, watch } = Vue;

    createApp({
      setup() {
        const canvas = ref(null);
        const ctx = ref(null);
        const data = ref(generateSampleData(200));
        const zoomLevel = ref(1);
        const sliderPosition = ref(0);
        const markerMode = ref(false);
        const selectedPoint = ref(null);
        const visibleDataRange = ref([0, 200]);
        const visibleDataPoints = ref(200);
        
        // 初始化
        onMounted(() => {
          ctx.value = canvas.value.getContext('2d');
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
          drawChart();
        });

        // 生成示例数据
        function generateSampleData(count) {
          const data = [];
          let value = 200;
          for (let i = 0; i < count; i++) {
            value += Math.random() * 10 - 5;
            data.push({ x: i, y: Math.max(50, Math.min(350, value)) });
          }
          return data;
        }

        // 调整Canvas大小
        function resizeCanvas() {
          if (!canvas.value) return;
          
          const container = canvas.value.parentElement;
          canvas.value.width = container.clientWidth;
          canvas.value.height = container.clientHeight;
          drawChart();
        }

        // 绘制图表
        function drawChart() {
          if (!ctx.value) return;
          
          const width = canvas.value.width;
          const height = canvas.value.height;
          
          // 清除画布
          ctx.value.clearRect(0, 0, width, height);
          
          // 绘制网格
          drawGrid();
          
          // 绘制折线
          drawLine();
          
          // 如果选中了点，绘制标记线
          if (selectedPoint.value) {
            drawMarker();
          }
        }

        // 绘制网格
        function drawGrid() {
          const width = canvas.value.width;
          const height = canvas.value.height;
          const cellSize = 50;
          
          ctx.value.beginPath();
          ctx.value.strokeStyle = '#e0e0e0';
          ctx.value.lineWidth = 1;
          
          // 垂直线
          for (let x = 0; x <= width; x += cellSize) {
            ctx.value.moveTo(x, 0);
            ctx.value.lineTo(x, height);
          }
          
          // 水平线
          for (let y = 0; y <= height; y += cellSize) {
            ctx.value.moveTo(0, y);
            ctx.value.lineTo(width, y);
          }
          
          ctx.value.stroke();
        }

        // 绘制折线
        function drawLine() {
          const width = canvas.value.width;
          const height = canvas.value.height;
          const visibleData = getVisibleData();
          
          if (visibleData.length === 0) return;
          
          // 计算Y轴范围
          const yValues = visibleData.map(point => point.y);
          const yMin = Math.min(...yValues);
          const yMax = Math.max(...yValues);
          const yRange = yMax - yMin || 1; // 避免除以0
          
          // 绘制折线
          ctx.value.beginPath();
          ctx.value.strokeStyle = '#3498db';
          ctx.value.lineWidth = 3;
          
          visibleData.forEach((point, index) => {
            const x = (index / (visibleData.length - 1)) * width;
            const y = height - ((point.y - yMin) / yRange) * height * 0.8 - height * 0.1;
            
            if (index === 0) {
              ctx.value.moveTo(x, y);
            } else {
              ctx.value.lineTo(x, y);
            }
          });
          
          ctx.value.stroke();
          
          // 绘制数据点
          ctx.value.fillStyle = '#2980b9';
          visibleData.forEach((point, index) => {
            if (index % 5 !== 0) return; // 仅绘制部分点以提高性能
            
            const x = (index / (visibleData.length - 1)) * width;
            const y = height - ((point.y - yMin) / yRange) * height * 0.8 - height * 0.1;
            
            ctx.value.beginPath();
            ctx.value.arc(x, y, 4, 0, Math.PI * 2);
            ctx.value.fill();
          });
        }

        // 绘制标记线
        function drawMarker() {
          const width = canvas.value.width;
          const height = canvas.value.height;
          const visibleData = getVisibleData();
          
          if (visibleData.length === 0) return;
          
          // 找到选中点在可见数据中的索引
          const index = visibleData.findIndex(point => 
            point.x === selectedPoint.value.x && point.y === selectedPoint.value.y
          );
          
          if (index === -1) return;
          
          // 计算Y轴范围
          const yValues = visibleData.map(point => point.y);
          const yMin = Math.min(...yValues);
          const yMax = Math.max(...yValues);
          const yRange = yMax - yMin || 1;
          
          const x = (index / (visibleData.length - 1)) * width;
          const y = height - ((selectedPoint.value.y - yMin) / yRange) * height * 0.8 - height * 0.1;
          
          // 绘制垂直线
          ctx.value.beginPath();
          ctx.value.strokeStyle = '#e74c3c';
          ctx.value.lineWidth = 2;
          ctx.value.setLineDash([5, 5]);
          ctx.value.moveTo(x, 0);
          ctx.value.lineTo(x, height);
          ctx.value.stroke();
          ctx.value.setLineDash([]);
          
          // 绘制点
        }

        // 获取当前可见的数据
        function getVisibleData() {
          const totalPoints = data.value.length;
          const visibleCount = Math.floor(totalPoints / zoomLevel.value);
          const startIndex = Math.floor((sliderPosition.value / 100) * (totalPoints - visibleCount));
          
          visibleDataRange.value = [startIndex, startIndex + visibleCount];
          visibleDataPoints.value = visibleCount;
          
          return data.value.slice(startIndex, startIndex + visibleCount);
        }

        // 放大
        function zoomIn() {
          if (zoomLevel.value < 5) {
            zoomLevel.value++;
            drawChart();
          }
        }

        // 缩小
        function zoomOut() {
          if (zoomLevel.value > 1) {
            zoomLevel.value--;
            drawChart();
          }
        }

        // 重置视图
        function resetView() {
          zoomLevel.value = 1;
          sliderPosition.value = 0;
          selectedPoint.value = null;
          drawChart();
        }

        // 切换标记模式
        function toggleMarkerMode() {
          markerMode.value = !markerMode.value;
          selectedPoint.value = null;
          drawChart();
        }

        // 更新视图位置
        function updateViewPosition() {
          drawChart();
        }

        // 处理Canvas点击
        function handleCanvasClick(event) {
          if (!markerMode.value) return;
          
          const rect = canvas.value.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const width = canvas.value.width;
          
          const visibleData = getVisibleData();
          if (visibleData.length === 0) return;
          
          // 找到最近的数据点
          const index = Math.round((x / width) * (visibleData.length - 1));
          selectedPoint.value = visibleData[index];
          
          drawChart();
        }

        // 监听缩放级别变化
        watch(zoomLevel, drawChart);

        return {
          canvas,
          data,
          zoomLevel,
          sliderPosition,
          markerMode,
          selectedPoint,
          visibleDataRange,
          visibleDataPoints,
          zoomIn,
          zoomOut,
          resetView,
          toggleMarkerMode,
          updateViewPosition,
          handleCanvasClick
        };
      }
    }).mount('#app');
  </script>
</body>
</html>